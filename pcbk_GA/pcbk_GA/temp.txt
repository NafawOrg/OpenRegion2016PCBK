orderdelimiter

for ( int i = 0; i < tuples.Count; )
                {
                    // параметры элемента стоящего на первом месте в tuple.
                    // он одниковый для всей подгруппы графа => считаем 1 раз
                    int start_idx = tuples[ i ].Item1;
                    int curr_idx = start_idx;
                    float volume = group[ start_idx - min_idx ].Volume;
                    float mean = volume;
                    float max = volume;
                    int neighbor_items = 1;

                    // пока tuple на первом месте содержит одинаковую цифру мы рассматриваем ту же самую
                    // подгруппу графа
                    while ( start_idx == curr_idx )
                    {
                        volume = group[ tuples[ i ].Item2 - min_idx ].Volume;
                        mean += volume;
                        neighbor_items++;
                        max = max > volume ? max : volume;
                        i++;

                        if ( i >= tuples.Count )
                            break;

                        curr_idx = tuples[ i ].Item1;
                    }

                    mean /= neighbor_items;
                    var variance = group.Select( x => Math.Pow( mean - x.Volume, 2 ) ).Sum() / group.Count;
                    var standard_deviation = ( float )Math.Sqrt( variance );
                    float threshold = mean + standard_deviation;

                    splittableOrders.AddRange( group.Where( x => x.Volume >= threshold ) );
                }